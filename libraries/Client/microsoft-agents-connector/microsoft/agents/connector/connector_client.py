# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/python@6.27.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from copy import deepcopy
from typing import Any, Awaitable, Callable
from typing_extensions import Self

from azure.core import AsyncPipelineClient
from azure.core.credentials_async import AsyncTokenCredential
from azure.core.pipeline import policies
from azure.core.rest import AsyncHttpResponse, HttpRequest
from microsoft.agents.authorization import AccessTokenProviderBase

from ._serialization import Deserializer, Serializer
from ._connector_client_configuration import ConnectorConfiguration
from .attachments_base import AttachmentsBase
from .conversations_base import ConversationsBase
from .connector_client_base import ConnectorClientBase
from .operations import (
    AttachmentsOperations,
    ConnectorInternalsOperations,
    ConversationsOperations,
)
from ._agents_token_credential_adapter import AgentsTokenCredentialAdapter


class ConnectorClient(
    ConnectorClientBase
):  # pylint: disable=client-accepts-api-version-keyword
    """The ABS Connector APIs allow agents to send and receive
    messages, button clicks, and other programmatic events when connecting with
    end users. This API also includes facilities to get conversation metadata
    and perform other operations (deletions and content editing). This REST API
    may be used directly over HTTP and Web Socket, but is easiest to use with
    the Azure SDK ConnectorClient.

    Â© 2020 Microsoft.

    :ivar attachments: AttachmentsOperations operations
    :vartype attachments: microsoft.agents.connector.operations.AttachmentsOperations
    :ivar conversations: ConversationsOperations operations
    :vartype conversations:
     microsoft.agents.connector.operations.ConversationsOperations
    :ivar connector_internals: ConnectorInternalsOperations operations
    :vartype connector_internals:
     microsoft.agents.connector.operations.ConnectorInternalsOperations
    :param credential_token_provider: Token provider object that returns a valid access token.
    :type credential_token_provider: from microsoft.agents.authentication import AccessTokenProviderBase
    :keyword endpoint: Service URL. Required. Default value is "".
    :paramtype endpoint: str
    """

    def __init__(  # pylint: disable=missing-client-constructor-parameter-credential
        self,
        endpoint: str,
        credential_token_provider: AccessTokenProviderBase,
        credential_resource_url: str,
        credential_scopes: list[str] = None,
        **kwargs: Any
    ) -> None:
        agents_token_credential = AgentsTokenCredentialAdapter(
            credential_token_provider, credential_resource_url
        )
        self._config = ConnectorConfiguration(
            credential=agents_token_credential,
            credential_scopes=credential_scopes,
            **kwargs
        )

        _policies = kwargs.pop("policies", None)
        if _policies is None:
            _policies = [
                policies.RequestIdPolicy(**kwargs),
                self._config.headers_policy,
                self._config.user_agent_policy,
                self._config.proxy_policy,
                policies.ContentDecodePolicy(**kwargs),
                self._config.redirect_policy,
                self._config.retry_policy,
                self._config.authentication_policy,
                self._config.custom_hook_policy,
                self._config.logging_policy,
                policies.DistributedTracingPolicy(**kwargs),
                (
                    policies.SensitiveHeaderCleanupPolicy(**kwargs)
                    if self._config.redirect_policy
                    else None
                ),
                self._config.http_logging_policy,
            ]
        self._client: AsyncPipelineClient = AsyncPipelineClient(
            base_url=endpoint, policies=_policies, **kwargs
        )

        self._serialize = Serializer()
        self._deserialize = Deserializer()
        self._serialize.client_side_validation = False
        self._attachments: AttachmentsBase = AttachmentsOperations(
            self._client, self._config, self._serialize, self._deserialize
        )
        self._conversations: ConversationsBase = ConversationsOperations(
            self._client, self._config, self._serialize, self._deserialize
        )
        self.connector_internals = ConnectorInternalsOperations(
            self._client, self._config, self._serialize, self._deserialize
        )

    @property
    def attachments(self) -> AttachmentsBase:
        return self._attachments

    @property
    def conversations(self) -> ConversationsBase:
        return self._conversations

    @property
    def base_uri(self) -> str:
        return self._client._base_url

    def send_request(
        self, request: HttpRequest, *, stream: bool = False, **kwargs: Any
    ) -> Awaitable[AsyncHttpResponse]:
        """Runs the network request through the client's chained policies.

        >> from azure.core.rest import HttpRequest
        >> request = HttpRequest("GET", "https://www.example.org/")
        <HttpRequest [GET], url: 'https://www.example.org/'>
        >> response = await client.send_request(request)
        <AsyncHttpResponse: 200 OK>

        For more information on this code flow, see https://aka.ms/azsdk/dpcodegen/python/send_request

        :param request: The network request you want to make. Required.
        :type request: ~azure.core.rest.HttpRequest
        :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
        :return: The response of your network call. Does not do error handling on your response.
        :rtype: ~azure.core.rest.AsyncHttpResponse
        """

        request_copy = deepcopy(request)
        request_copy.url = self._client.format_url(request_copy.url)
        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore

    async def close(self) -> None:
        await self._client.close()

    async def __aenter__(self) -> Self:
        await self._client.__aenter__()
        return self

    async def __aexit__(self, *exc_details: Any) -> None:
        await self._client.__aexit__(*exc_details)
