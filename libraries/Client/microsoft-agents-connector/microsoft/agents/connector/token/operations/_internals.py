# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/python@6.27.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import (
    Any,
    Callable,
    Dict,
    IO,
    List,
    Optional,
    TypeVar,
    Union,
    cast,
    overload,
)

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from ..._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]
]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_agent_sign_in_get_sign_in_url_request(  # pylint: disable=name-too-long
    *,
    state: str,
    code_challenge: Optional[str] = None,
    emulator_url: Optional[str] = None,
    final_redirect: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "text/plain")

    # Construct URL
    _url = "/api/botsignin/GetSignInUrl"

    # Construct parameters
    _params["state"] = _SERIALIZER.query("state", state, "str")
    if code_challenge is not None:
        _params["code_challenge"] = _SERIALIZER.query(
            "code_challenge", code_challenge, "str"
        )
    if emulator_url is not None:
        _params["emulatorUrl"] = _SERIALIZER.query("emulator_url", emulator_url, "str")
    if final_redirect is not None:
        _params["finalRedirect"] = _SERIALIZER.query(
            "final_redirect", final_redirect, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_agent_sign_in_get_sign_in_resource_request(  # pylint: disable=name-too-long
    *,
    state: str,
    code_challenge: Optional[str] = None,
    emulator_url: Optional[str] = None,
    final_redirect: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/botsignin/GetSignInResource"

    # Construct parameters
    _params["state"] = _SERIALIZER.query("state", state, "str")
    if code_challenge is not None:
        _params["code_challenge"] = _SERIALIZER.query(
            "code_challenge", code_challenge, "str"
        )
    if emulator_url is not None:
        _params["emulatorUrl"] = _SERIALIZER.query("emulator_url", emulator_url, "str")
    if final_redirect is not None:
        _params["finalRedirect"] = _SERIALIZER.query(
            "final_redirect", final_redirect, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_user_token_get_token_request(
    *,
    user_id: str,
    connection_name: str,
    channel_id: Optional[str] = None,
    code: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/usertoken/GetToken"

    # Construct parameters
    _params["userId"] = _SERIALIZER.query("user_id", user_id, "str")
    _params["connectionName"] = _SERIALIZER.query(
        "connection_name", connection_name, "str"
    )
    if channel_id is not None:
        _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")
    if code is not None:
        _params["code"] = _SERIALIZER.query("code", code, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_user_token_get_aad_tokens_request(
    *,
    user_id: str,
    connection_name: str,
    channel_id: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/usertoken/GetAadTokens"

    # Construct parameters
    _params["userId"] = _SERIALIZER.query("user_id", user_id, "str")
    _params["connectionName"] = _SERIALIZER.query(
        "connection_name", connection_name, "str"
    )
    if channel_id is not None:
        _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="POST", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_user_token_sign_out_request(
    *,
    user_id: str,
    connection_name: Optional[str] = None,
    channel_id: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/usertoken/SignOut"

    # Construct parameters
    _params["userId"] = _SERIALIZER.query("user_id", user_id, "str")
    if connection_name is not None:
        _params["connectionName"] = _SERIALIZER.query(
            "connection_name", connection_name, "str"
        )
    if channel_id is not None:
        _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="DELETE", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_user_token_get_token_status_request(  # pylint: disable=name-too-long
    *,
    user_id: str,
    channel_id: Optional[str] = None,
    include: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/usertoken/GetTokenStatus"

    # Construct parameters
    _params["userId"] = _SERIALIZER.query("user_id", user_id, "str")
    if channel_id is not None:
        _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_user_token_exchange_token_request(
    *, user_id: str, connection_name: str, channel_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/api/usertoken/exchange"

    # Construct parameters
    _params["userId"] = _SERIALIZER.query("user_id", user_id, "str")
    _params["connectionName"] = _SERIALIZER.query(
        "connection_name", connection_name, "str"
    )
    _params["channelId"] = _SERIALIZER.query("channel_id", channel_id, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="POST", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_token_internals_post_token_status_request(
    **kwargs: Any,
) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v3/tokenInternals/tokenStatus"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_token_internals_post_token_exchange_resource_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v3/tokenInternals/tokenExchangeResource"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_token_internals_post_token_response_request(
    **kwargs: Any,
) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v3/tokenInternals/tokenResponse"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_token_internals_post_sign_in_url_response_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v3/tokenInternals/signInUrlResponse"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_token_internals_post_error_response_request(
    **kwargs: Any,
) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v3/tokenInternals/errorResponse"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


class AgentSignInOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agents.protocols.connector.Token`'s
        :attr:`agent_sign_in` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def get_sign_in_url(
        self,
        *,
        state: str,
        code_challenge: Optional[str] = None,
        emulator_url: Optional[str] = None,
        final_redirect: Optional[str] = None,
        **kwargs: Any,
    ) -> str:
        """get_sign_in_url.

        :keyword state: Required.
        :paramtype state: str
        :keyword code_challenge: Default value is None.
        :paramtype code_challenge: str
        :keyword emulator_url: Default value is None.
        :paramtype emulator_url: str
        :keyword final_redirect: Default value is None.
        :paramtype final_redirect: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_agent_sign_in_get_sign_in_url_request(
            state=state,
            code_challenge=code_challenge,
            emulator_url=emulator_url,
            final_redirect=final_redirect,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(str, deserialized), {})  # type: ignore

        return cast(str, deserialized)  # type: ignore

    @distributed_trace
    def get_sign_in_resource(
        self,
        *,
        state: str,
        code_challenge: Optional[str] = None,
        emulator_url: Optional[str] = None,
        final_redirect: Optional[str] = None,
        **kwargs: Any,
    ) -> JSON:
        """get_sign_in_resource.

        :keyword state: Required.
        :paramtype state: str
        :keyword code_challenge: Default value is None.
        :paramtype code_challenge: str
        :keyword emulator_url: Default value is None.
        :paramtype emulator_url: str
        :keyword final_redirect: Default value is None.
        :paramtype final_redirect: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "signInLink": "str",
                    "tokenExchangeResource": {
                        "id": "str",
                        "providerId": "str",
                        "uri": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_agent_sign_in_get_sign_in_resource_request(
            state=state,
            code_challenge=code_challenge,
            emulator_url=emulator_url,
            final_redirect=final_redirect,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class UserTokenOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agents.protocols.connector.Token`'s
        :attr:`user_token` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def get_token(
        self,
        *,
        user_id: str,
        connection_name: str,
        channel_id: Optional[str] = None,
        code: Optional[str] = None,
        **kwargs: Any,
    ) -> JSON:
        """get_token.

        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Default value is None.
        :paramtype channel_id: str
        :keyword code: Default value is None.
        :paramtype code: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_user_token_get_token_request(
            user_id=user_id,
            connection_name=connection_name,
            channel_id=channel_id,
            code=code,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def get_aad_tokens(
        self,
        body: Optional[JSON] = None,
        *,
        user_id: str,
        connection_name: str,
        channel_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, JSON]:
        """get_aad_tokens.

        :param body: Default value is None.
        :type body: JSON
        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Default value is None.
        :paramtype channel_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to JSON object
        :rtype: dict[str, JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "resourceUrls": [
                        "str"
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "str": {
                        "channelId": "str",
                        "connectionName": "str",
                        "expiration": "str",
                        "token": "str"
                    }
                }
        """

    @overload
    def get_aad_tokens(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        user_id: str,
        connection_name: str,
        channel_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, JSON]:
        """get_aad_tokens.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Default value is None.
        :paramtype channel_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to JSON object
        :rtype: dict[str, JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {
                        "channelId": "str",
                        "connectionName": "str",
                        "expiration": "str",
                        "token": "str"
                    }
                }
        """

    @distributed_trace
    def get_aad_tokens(
        self,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        *,
        user_id: str,
        connection_name: str,
        channel_id: Optional[str] = None,
        **kwargs: Any,
    ) -> Dict[str, JSON]:
        """get_aad_tokens.

        :param body: Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Default value is None.
        :paramtype channel_id: str
        :return: dict mapping str to JSON object
        :rtype: dict[str, JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "resourceUrls": [
                        "str"
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "str": {
                        "channelId": "str",
                        "connectionName": "str",
                        "expiration": "str",
                        "token": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Dict[str, JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_user_token_get_aad_tokens_request(
            user_id=user_id,
            connection_name=connection_name,
            channel_id=channel_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, JSON], deserialized), {})  # type: ignore

        return cast(Dict[str, JSON], deserialized)  # type: ignore

    @distributed_trace
    def sign_out(
        self,
        *,
        user_id: str,
        connection_name: Optional[str] = None,
        channel_id: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[JSON]:
        """sign_out.

        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Default value is None.
        :paramtype connection_name: str
        :keyword channel_id: Default value is None.
        :paramtype channel_id: str
        :return: JSON or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        _request = build_user_token_sign_out_request(
            user_id=user_id,
            connection_name=connection_name,
            channel_id=channel_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_token_status(
        self,
        *,
        user_id: str,
        channel_id: Optional[str] = None,
        include: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """get_token_status.

        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword channel_id: Default value is None.
        :paramtype channel_id: str
        :keyword include: Default value is None.
        :paramtype include: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "channelId": "str",
                        "connectionName": "str",
                        "hasToken": bool,
                        "serviceProviderDisplayName": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_user_token_get_token_status_request(
            user_id=user_id,
            channel_id=channel_id,
            include=include,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def exchange_token(
        self,
        body: Optional[JSON] = None,
        *,
        user_id: str,
        connection_name: str,
        channel_id: str,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """exchange_token.

        :param body: Default value is None.
        :type body: JSON
        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Required.
        :paramtype channel_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "token": "str",
                    "uri": "str"
                }

                # response body for status code(s): 200, 404
                response == {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """

    @overload
    def exchange_token(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        user_id: str,
        connection_name: str,
        channel_id: str,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """exchange_token.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Required.
        :paramtype channel_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """

    @distributed_trace
    def exchange_token(
        self,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        *,
        user_id: str,
        connection_name: str,
        channel_id: str,
        **kwargs: Any,
    ) -> JSON:
        """exchange_token.

        :param body: Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :keyword user_id: Required.
        :paramtype user_id: str
        :keyword connection_name: Required.
        :paramtype connection_name: str
        :keyword channel_id: Required.
        :paramtype channel_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "token": "str",
                    "uri": "str"
                }

                # response body for status code(s): 200, 404
                response == {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_user_token_exchange_token_request(
            user_id=user_id,
            connection_name=connection_name,
            channel_id=channel_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class TokenInternalsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agents.protocols.connector.Token`'s
        :attr:`token_internals` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def post_token_status(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostTokenStatus.

        PostTokenStatus.

        :param body: TokenStatus. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "channelId": "str",
                    "connectionName": "str",
                    "hasToken": bool,
                    "serviceProviderDisplayName": "str"
                }
        """

    @overload
    def post_token_status(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostTokenStatus.

        PostTokenStatus.

        :param body: TokenStatus. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def post_token_status(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenStatus.

        PostTokenStatus.

        :param body: TokenStatus. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "channelId": "str",
                    "connectionName": "str",
                    "hasToken": bool,
                    "serviceProviderDisplayName": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_token_internals_post_token_status_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def post_token_exchange_resource(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostTokenExchangeResource.

        PostTokenExchangeResource.

        :param body: TokenExchangeResource. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "providerId": "str",
                    "uri": "str"
                }
        """

    @overload
    def post_token_exchange_resource(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostTokenExchangeResource.

        PostTokenExchangeResource.

        :param body: TokenExchangeResource. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def post_token_exchange_resource(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenExchangeResource.

        PostTokenExchangeResource.

        :param body: TokenExchangeResource. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "providerId": "str",
                    "uri": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_token_internals_post_token_exchange_resource_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def post_token_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostTokenResponse.

        PostTokenResponse.

        :param body: TokenResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """

    @overload
    def post_token_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostTokenResponse.

        PostTokenResponse.

        :param body: TokenResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def post_token_response(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenResponse.

        PostTokenResponse.

        :param body: TokenResponse. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_token_internals_post_token_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def post_sign_in_url_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostSignInUrlResponse.

        PostSignInUrlResponse.

        :param body: SignInUrlResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "signInLink": "str",
                    "tokenExchangeResource": {
                        "id": "str",
                        "providerId": "str",
                        "uri": "str"
                    }
                }
        """

    @overload
    def post_sign_in_url_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostSignInUrlResponse.

        PostSignInUrlResponse.

        :param body: SignInUrlResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def post_sign_in_url_response(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostSignInUrlResponse.

        PostSignInUrlResponse.

        :param body: SignInUrlResponse. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "signInLink": "str",
                    "tokenExchangeResource": {
                        "id": "str",
                        "providerId": "str",
                        "uri": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_token_internals_post_sign_in_url_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def post_error_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostErrorResponse.

        PostErrorResponse.

        :param body: ErrorResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "error": {
                        "code": "str",
                        "innerHttpError": {
                            "body": {},
                            "statusCode": 0
                        },
                        "message": "str"
                    }
                }
        """

    @overload
    def post_error_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """PostErrorResponse.

        PostErrorResponse.

        :param body: ErrorResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def post_error_response(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostErrorResponse.

        PostErrorResponse.

        :param body: ErrorResponse. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "error": {
                        "code": "str",
                        "innerHttpError": {
                            "body": {},
                            "statusCode": 0
                        },
                        "message": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_token_internals_post_error_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
