# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/python@6.27.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import (
    Any,
    AsyncIterator,
    Callable,
    Dict,
    IO,
    List,
    Optional,
    TypeVar,
    Union,
    cast,
    overload,
)

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..attachments_base import AttachmentsBase
from ..conversations_base import ConversationsBase
from ._internals import (
    build_attachments_get_attachment_info_request,
    build_attachments_get_attachment_request,
    build_connector_internals_activity_event_names_request,
    build_connector_internals_activity_request,
    build_connector_internals_adaptive_card_invoke_action_request,
    build_connector_internals_adaptive_card_invoke_response_request,
    build_connector_internals_adaptive_card_invoke_value_request,
    build_connector_internals_animation_card_request,
    build_connector_internals_attachment_info_request,
    build_connector_internals_audio_card_request,
    build_connector_internals_basic_card_request,
    build_connector_internals_conversation_resource_response_request,
    build_connector_internals_conversations_result_request,
    build_connector_internals_expected_replies_request,
    build_connector_internals_hero_card_request,
    build_connector_internals_invoke_response_request,
    build_connector_internals_media_card_request,
    build_connector_internals_mention_request,
    build_connector_internals_o_auth_card_request,
    build_connector_internals_paged_members_result_request,
    build_connector_internals_post_error_response_request,
    build_connector_internals_receipt_card_request,
    build_connector_internals_resource_response_request,
    build_connector_internals_search_invoke_response_request,
    build_connector_internals_search_invoke_value_request,
    build_connector_internals_signin_card_request,
    build_connector_internals_thumbnail_card_request,
    build_connector_internals_token_exchange_invoke_request_request,
    build_connector_internals_token_exchange_invoke_response_request,
    build_connector_internals_token_exchange_resource_request,
    build_connector_internals_token_exchange_state_request,
    build_connector_internals_token_response_request,
    build_connector_internals_video_card_request,
    build_conversations_create_conversation_request,
    build_conversations_delete_activity_request,
    build_conversations_delete_conversation_member_request,
    build_conversations_get_activity_members_request,
    build_conversations_get_conversation_member_request,
    build_conversations_get_conversation_members_request,
    build_conversations_get_conversation_paged_members_request,
    build_conversations_get_conversations_request,
    build_conversations_reply_to_activity_request,
    build_conversations_send_conversation_history_request,
    build_conversations_send_to_conversation_request,
    build_conversations_update_activity_request,
    build_conversations_upload_attachment_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]
]


class AttachmentsOperations(AttachmentsBase):
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agents.connector.Connector`'s
        :attr:`attachments` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace_async
    async def get_attachment_info(self, attachment_id: str, **kwargs: Any) -> JSON:
        """GetAttachmentInfo.

        Get AttachmentInfo structure describing the attachment views.

        :param attachment_id: attachment id. Required.
        :type attachment_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",
                    "type": "str",
                    "views": [
                        {
                            "size": 0,
                            "viewId": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_attachments_get_attachment_info_request(
            attachment_id=attachment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_attachment(
        self, attachment_id: str, view_id: str, **kwargs: Any
    ) -> Optional[AsyncIterator[bytes]]:
        """GetAttachment.

        Get the named view as binary content.

        :param attachment_id: attachment id. Required.
        :type attachment_id: str
        :param view_id: View id from attachmentInfo. Required.
        :type view_id: str
        :return: AsyncIterator[bytes] or None
        :rtype: AsyncIterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[AsyncIterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_attachments_get_attachment_request(
            attachment_id=attachment_id,
            view_id=view_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 301, 302]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ConversationsOperations(ConversationsBase):
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agents.connector.Connector`'s
        :attr:`conversations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace_async
    async def get_conversations(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """GetConversations.

        List the Conversations in which this agent has participated.

        GET from this method with a skip token

        The return value is a ConversationsResult, which contains an array of ConversationMembers and a
        skip token.  If the skip token is not empty, then
        there are further values to be returned. Call this method again with the returned token to get
        more values.

        Each ConversationMembers object contains the ID of the conversation and an array of
        ChannelAccounts that describe the members of the conversation.

        :keyword continuation_token_parameter: skip or continuation token. Default value is None.
        :paramtype continuation_token_parameter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuationToken": "str",
                    "conversations": [
                        {
                            "id": "str",
                            "members": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ]
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_conversations_get_conversations_request(
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_conversation(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """CreateConversation.

        Create a new Conversation.

        POST to this method with a


        * Agent being the agent creating the conversation
        * IsGroup set to true if this is not a direct message (default is false)
        * Array containing the members to include in the conversation

        The return value is a ResourceResponse which contains a conversation id which is suitable for
        use
        in the message payload and REST API uris.

        Most channels only support the semantics of agents initiating a direct message conversation.

        :param body: Parameters to create the conversation from. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activity": {
                        "action": "str",
                        "attachmentLayout": "str",
                        "attachments": [
                            {
                                "content": {},
                                "contentType": "str",
                                "contentUrl": "str",
                                "name": "str",
                                "thumbnailUrl": "str"
                            }
                        ],
                        "callerId": "str",
                        "channelData": {},
                        "channelId": "str",
                        "code": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "deliveryMode": "str",
                        "entities": [
                            {
                                "type": "str"
                            }
                        ],
                        "expiration": "2020-02-20 00:00:00",
                        "from": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "historyDisclosed": bool,
                        "id": "str",
                        "importance": "str",
                        "inputHint": "str",
                        "label": "str",
                        "listenFor": [
                            "str"
                        ],
                        "localTimestamp": "2020-02-20 00:00:00",
                        "localTimezone": "str",
                        "locale": "str",
                        "membersAdded": [
                            {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            }
                        ],
                        "membersRemoved": [
                            {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            }
                        ],
                        "name": "str",
                        "reactionsAdded": [
                            {
                                "type": "str"
                            }
                        ],
                        "reactionsRemoved": [
                            {
                                "type": "str"
                            }
                        ],
                        "recipient": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "relatesTo": {
                            "activityId": "str",
                            "bot": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "channelId": "str",
                            "conversation": {
                                "aadObjectId": "str",
                                "conversationType": "str",
                                "id": "str",
                                "isGroup": bool,
                                "name": "str",
                                "role": "str",
                                "tenantId": "str"
                            },
                            "locale": "str",
                            "serviceUrl": "str",
                            "user": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            }
                        },
                        "replyToId": "str",
                        "semanticAction": {
                            "entities": {
                                "str": {
                                    "type": "str"
                                }
                            },
                            "id": "str",
                            "state": "str"
                        },
                        "serviceUrl": "str",
                        "speak": "str",
                        "suggestedActions": {
                            "actions": [
                                {
                                    "channelData": {},
                                    "displayText": "str",
                                    "image": "str",
                                    "imageAltText": "str",
                                    "text": "str",
                                    "title": "str",
                                    "type": "str",
                                    "value": {}
                                }
                            ],
                            "to": [
                                "str"
                            ]
                        },
                        "summary": "str",
                        "text": "str",
                        "textFormat": "str",
                        "textHighlights": [
                            {
                                "occurrence": 0,
                                "text": "str"
                            }
                        ],
                        "timestamp": "2020-02-20 00:00:00",
                        "topicName": "str",
                        "type": "str",
                        "value": {},
                        "valueType": "str"
                    },
                    "bot": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "channelData": {},
                    "isGroup": bool,
                    "members": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "tenantId": "str",
                    "topicName": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "activityId": "str",
                    "id": "str",
                    "serviceUrl": "str"
                }
        """

    @overload
    async def create_conversation(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """CreateConversation.

        Create a new Conversation.

        POST to this method with a


        * Bot being the agent creating the conversation
        * IsGroup set to true if this is not a direct message (default is false)
        * Array containing the members to include in the conversation

        The return value is a ResourceResponse which contains a conversation id which is suitable for
        use
        in the message payload and REST API uris.

        Most channels only support the semantics of agents initiating a direct message conversation.

        :param body: Parameters to create the conversation from. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201, 202
                response == {
                    "activityId": "str",
                    "id": "str",
                    "serviceUrl": "str"
                }
        """

    @distributed_trace_async
    async def create_conversation(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> JSON:
        """CreateConversation.

        Create a new Conversation.

        POST to this method with a


        * Bot being the agent creating the conversation
        * IsGroup set to true if this is not a direct message (default is false)
        * Array containing the members to include in the conversation

        The return value is a ResourceResponse which contains a conversation id which is suitable for
        use
        in the message payload and REST API uris.

        Most channels only support the semantics of agents initiating a direct message conversation.

        :param body: Parameters to create the conversation from. Is either a JSON type or a IO[bytes]
         type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activity": {
                        "action": "str",
                        "attachmentLayout": "str",
                        "attachments": [
                            {
                                "content": {},
                                "contentType": "str",
                                "contentUrl": "str",
                                "name": "str",
                                "thumbnailUrl": "str"
                            }
                        ],
                        "callerId": "str",
                        "channelData": {},
                        "channelId": "str",
                        "code": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "deliveryMode": "str",
                        "entities": [
                            {
                                "type": "str"
                            }
                        ],
                        "expiration": "2020-02-20 00:00:00",
                        "from": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "historyDisclosed": bool,
                        "id": "str",
                        "importance": "str",
                        "inputHint": "str",
                        "label": "str",
                        "listenFor": [
                            "str"
                        ],
                        "localTimestamp": "2020-02-20 00:00:00",
                        "localTimezone": "str",
                        "locale": "str",
                        "membersAdded": [
                            {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            }
                        ],
                        "membersRemoved": [
                            {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            }
                        ],
                        "name": "str",
                        "reactionsAdded": [
                            {
                                "type": "str"
                            }
                        ],
                        "reactionsRemoved": [
                            {
                                "type": "str"
                            }
                        ],
                        "recipient": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "relatesTo": {
                            "activityId": "str",
                            "bot": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "channelId": "str",
                            "conversation": {
                                "aadObjectId": "str",
                                "conversationType": "str",
                                "id": "str",
                                "isGroup": bool,
                                "name": "str",
                                "role": "str",
                                "tenantId": "str"
                            },
                            "locale": "str",
                            "serviceUrl": "str",
                            "user": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            }
                        },
                        "replyToId": "str",
                        "semanticAction": {
                            "entities": {
                                "str": {
                                    "type": "str"
                                }
                            },
                            "id": "str",
                            "state": "str"
                        },
                        "serviceUrl": "str",
                        "speak": "str",
                        "suggestedActions": {
                            "actions": [
                                {
                                    "channelData": {},
                                    "displayText": "str",
                                    "image": "str",
                                    "imageAltText": "str",
                                    "text": "str",
                                    "title": "str",
                                    "type": "str",
                                    "value": {}
                                }
                            ],
                            "to": [
                                "str"
                            ]
                        },
                        "summary": "str",
                        "text": "str",
                        "textFormat": "str",
                        "textHighlights": [
                            {
                                "occurrence": 0,
                                "text": "str"
                            }
                        ],
                        "timestamp": "2020-02-20 00:00:00",
                        "topicName": "str",
                        "type": "str",
                        "value": {},
                        "valueType": "str"
                    },
                    "bot": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "channelData": {},
                    "isGroup": bool,
                    "members": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "tenantId": "str",
                    "topicName": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "activityId": "str",
                    "id": "str",
                    "serviceUrl": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_conversations_create_conversation_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def send_to_conversation(
        self,
        conversation_id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """SendToConversation.

        This method allows you to send an activity to the end of a conversation.

        This is slightly different from ReplyToActivity().


        * SendToConversation(conversationId) - will append the activity to the end of the conversation
        according to the timestamp or semantics of the channel.
        * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another
        activity, if the channel supports it. If the channel does not support nested replies,
        ReplyToActivity falls back to SendToConversation.

        Use ReplyToActivity when replying to a specific activity in the conversation.

        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Activity to send. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @overload
    async def send_to_conversation(
        self,
        conversation_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """SendToConversation.

        This method allows you to send an activity to the end of a conversation.

        This is slightly different from ReplyToActivity().


        * SendToConversation(conversationId) - will append the activity to the end of the conversation
        according to the timestamp or semantics of the channel.
        * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another
        activity, if the channel supports it. If the channel does not support nested replies,
        ReplyToActivity falls back to SendToConversation.

        Use ReplyToActivity when replying to a specific activity in the conversation.

        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Activity to send. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @distributed_trace_async
    async def send_to_conversation(
        self,
        conversation_id: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        """SendToConversation.

        This method allows you to send an activity to the end of a conversation.

        This is slightly different from ReplyToActivity().


        * SendToConversation(conversationId) - will append the activity to the end of the conversation
        according to the timestamp or semantics of the channel.
        * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another
        activity, if the channel supports it. If the channel does not support nested replies,
        ReplyToActivity falls back to SendToConversation.

        Use ReplyToActivity when replying to a specific activity in the conversation.

        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Activity to send. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_conversations_send_to_conversation_request(
            conversation_id=conversation_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def send_conversation_history(
        self,
        conversation_id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """SendConversationHistory.

        This method allows you to upload the historic activities to the conversation.

        Sender must ensure that the historic activities have unique ids and appropriate timestamps. The
        ids are used by the client to deal with duplicate activities and the timestamps are used by the
        client to render the activities in the right order.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Historic activities. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activities": [
                        {
                            "action": "str",
                            "attachmentLayout": "str",
                            "attachments": [
                                {
                                    "content": {},
                                    "contentType": "str",
                                    "contentUrl": "str",
                                    "name": "str",
                                    "thumbnailUrl": "str"
                                }
                            ],
                            "callerId": "str",
                            "channelData": {},
                            "channelId": "str",
                            "code": "str",
                            "conversation": {
                                "aadObjectId": "str",
                                "conversationType": "str",
                                "id": "str",
                                "isGroup": bool,
                                "name": "str",
                                "role": "str",
                                "tenantId": "str"
                            },
                            "deliveryMode": "str",
                            "entities": [
                                {
                                    "type": "str"
                                }
                            ],
                            "expiration": "2020-02-20 00:00:00",
                            "from": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "historyDisclosed": bool,
                            "id": "str",
                            "importance": "str",
                            "inputHint": "str",
                            "label": "str",
                            "listenFor": [
                                "str"
                            ],
                            "localTimestamp": "2020-02-20 00:00:00",
                            "localTimezone": "str",
                            "locale": "str",
                            "membersAdded": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "membersRemoved": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "name": "str",
                            "reactionsAdded": [
                                {
                                    "type": "str"
                                }
                            ],
                            "reactionsRemoved": [
                                {
                                    "type": "str"
                                }
                            ],
                            "recipient": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "relatesTo": {
                                "activityId": "str",
                                "bot": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                },
                                "channelId": "str",
                                "conversation": {
                                    "aadObjectId": "str",
                                    "conversationType": "str",
                                    "id": "str",
                                    "isGroup": bool,
                                    "name": "str",
                                    "role": "str",
                                    "tenantId": "str"
                                },
                                "locale": "str",
                                "serviceUrl": "str",
                                "user": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            },
                            "replyToId": "str",
                            "semanticAction": {
                                "entities": {
                                    "str": {
                                        "type": "str"
                                    }
                                },
                                "id": "str",
                                "state": "str"
                            },
                            "serviceUrl": "str",
                            "speak": "str",
                            "suggestedActions": {
                                "actions": [
                                    {
                                        "channelData": {},
                                        "displayText": "str",
                                        "image": "str",
                                        "imageAltText": "str",
                                        "text": "str",
                                        "title": "str",
                                        "type": "str",
                                        "value": {}
                                    }
                                ],
                                "to": [
                                    "str"
                                ]
                            },
                            "summary": "str",
                            "text": "str",
                            "textFormat": "str",
                            "textHighlights": [
                                {
                                    "occurrence": 0,
                                    "text": "str"
                                }
                            ],
                            "timestamp": "2020-02-20 00:00:00",
                            "topicName": "str",
                            "type": "str",
                            "value": {},
                            "valueType": "str"
                        }
                    ]
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @overload
    async def send_conversation_history(
        self,
        conversation_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """SendConversationHistory.

        This method allows you to upload the historic activities to the conversation.

        Sender must ensure that the historic activities have unique ids and appropriate timestamps. The
        ids are used by the client to deal with duplicate activities and the timestamps are used by the
        client to render the activities in the right order.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Historic activities. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @distributed_trace_async
    async def send_conversation_history(
        self,
        conversation_id: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        """SendConversationHistory.

        This method allows you to upload the historic activities to the conversation.

        Sender must ensure that the historic activities have unique ids and appropriate timestamps. The
        ids are used by the client to deal with duplicate activities and the timestamps are used by the
        client to render the activities in the right order.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Historic activities. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activities": [
                        {
                            "action": "str",
                            "attachmentLayout": "str",
                            "attachments": [
                                {
                                    "content": {},
                                    "contentType": "str",
                                    "contentUrl": "str",
                                    "name": "str",
                                    "thumbnailUrl": "str"
                                }
                            ],
                            "callerId": "str",
                            "channelData": {},
                            "channelId": "str",
                            "code": "str",
                            "conversation": {
                                "aadObjectId": "str",
                                "conversationType": "str",
                                "id": "str",
                                "isGroup": bool,
                                "name": "str",
                                "role": "str",
                                "tenantId": "str"
                            },
                            "deliveryMode": "str",
                            "entities": [
                                {
                                    "type": "str"
                                }
                            ],
                            "expiration": "2020-02-20 00:00:00",
                            "from": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "historyDisclosed": bool,
                            "id": "str",
                            "importance": "str",
                            "inputHint": "str",
                            "label": "str",
                            "listenFor": [
                                "str"
                            ],
                            "localTimestamp": "2020-02-20 00:00:00",
                            "localTimezone": "str",
                            "locale": "str",
                            "membersAdded": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "membersRemoved": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "name": "str",
                            "reactionsAdded": [
                                {
                                    "type": "str"
                                }
                            ],
                            "reactionsRemoved": [
                                {
                                    "type": "str"
                                }
                            ],
                            "recipient": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "relatesTo": {
                                "activityId": "str",
                                "bot": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                },
                                "channelId": "str",
                                "conversation": {
                                    "aadObjectId": "str",
                                    "conversationType": "str",
                                    "id": "str",
                                    "isGroup": bool,
                                    "name": "str",
                                    "role": "str",
                                    "tenantId": "str"
                                },
                                "locale": "str",
                                "serviceUrl": "str",
                                "user": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            },
                            "replyToId": "str",
                            "semanticAction": {
                                "entities": {
                                    "str": {
                                        "type": "str"
                                    }
                                },
                                "id": "str",
                                "state": "str"
                            },
                            "serviceUrl": "str",
                            "speak": "str",
                            "suggestedActions": {
                                "actions": [
                                    {
                                        "channelData": {},
                                        "displayText": "str",
                                        "image": "str",
                                        "imageAltText": "str",
                                        "text": "str",
                                        "title": "str",
                                        "type": "str",
                                        "value": {}
                                    }
                                ],
                                "to": [
                                    "str"
                                ]
                            },
                            "summary": "str",
                            "text": "str",
                            "textFormat": "str",
                            "textHighlights": [
                                {
                                    "occurrence": 0,
                                    "text": "str"
                                }
                            ],
                            "timestamp": "2020-02-20 00:00:00",
                            "topicName": "str",
                            "type": "str",
                            "value": {},
                            "valueType": "str"
                        }
                    ]
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_conversations_send_conversation_history_request(
            conversation_id=conversation_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_activity(
        self,
        conversation_id: str,
        activity_id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """UpdateActivity.

        Edit an existing activity.

        Some channels allow you to edit an existing activity to reflect the new state of an agent
        conversation.

        For example, you can remove buttons after someone has clicked "Approve" button.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId to update. Required.
        :type activity_id: str
        :param body: replacement Activity. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @overload
    async def update_activity(
        self,
        conversation_id: str,
        activity_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """UpdateActivity.

        Edit an existing activity.

        Some channels allow you to edit an existing activity to reflect the new state of an agent
        conversation.

        For example, you can remove buttons after someone has clicked "Approve" button.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId to update. Required.
        :type activity_id: str
        :param body: replacement Activity. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @distributed_trace_async
    async def update_activity(
        self,
        conversation_id: str,
        activity_id: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        """UpdateActivity.

        Edit an existing activity.

        Some channels allow you to edit an existing activity to reflect the new state of an agent
        conversation.

        For example, you can remove buttons after someone has clicked "Approve" button.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId to update. Required.
        :type activity_id: str
        :param body: replacement Activity. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_conversations_update_activity_request(
            conversation_id=conversation_id,
            activity_id=activity_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def reply_to_activity(
        self,
        conversation_id: str,
        activity_id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """ReplyToActivity.

        This method allows you to reply to an activity.

        This is slightly different from SendToConversation().


        * SendToConversation(conversationId) - will append the activity to the end of the conversation
        according to the timestamp or semantics of the channel.
        * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another
        activity, if the channel supports it. If the channel does not support nested replies,
        ReplyToActivity falls back to SendToConversation.

        Use ReplyToActivity when replying to a specific activity in the conversation.

        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId the reply is to (OPTIONAL). Required.
        :type activity_id: str
        :param body: Activity to send. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @overload
    async def reply_to_activity(
        self,
        conversation_id: str,
        activity_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """ReplyToActivity.

        This method allows you to reply to an activity.

        This is slightly different from SendToConversation().


        * SendToConversation(conversationId) - will append the activity to the end of the conversation
        according to the timestamp or semantics of the channel.
        * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another
        activity, if the channel supports it. If the channel does not support nested replies,
        ReplyToActivity falls back to SendToConversation.

        Use ReplyToActivity when replying to a specific activity in the conversation.

        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId the reply is to (OPTIONAL). Required.
        :type activity_id: str
        :param body: Activity to send. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @distributed_trace_async
    async def reply_to_activity(
        self,
        conversation_id: str,
        activity_id: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        """ReplyToActivity.

        This method allows you to reply to an activity.

        This is slightly different from SendToConversation().


        * SendToConversation(conversationId) - will append the activity to the end of the conversation
        according to the timestamp or semantics of the channel.
        * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another
        activity, if the channel supports it. If the channel does not support nested replies,
        ReplyToActivity falls back to SendToConversation.

        Use ReplyToActivity when replying to a specific activity in the conversation.

        Use SendToConversation in all other cases.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId the reply is to (OPTIONAL). Required.
        :type activity_id: str
        :param body: Activity to send. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_conversations_reply_to_activity_request(
            conversation_id=conversation_id,
            activity_id=activity_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False

        # TODO: Story for configuration of enforce_https
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, enforce_https=False, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_activity(
        self, conversation_id: str, activity_id: str, **kwargs: Any
    ) -> None:
        """DeleteActivity.

        Delete an existing activity.

        Some channels allow you to delete an existing activity, and if successful this method will
        remove the specified activity.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: activityId to delete. Required.
        :type activity_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_conversations_delete_activity_request(
            conversation_id=conversation_id,
            activity_id=activity_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_conversation_members(
        self, conversation_id: str, **kwargs: Any
    ) -> List[JSON]:
        """GetConversationMembers.

        Enumerate the members of a conversation.

        This REST API takes a ConversationId and returns an array of ChannelAccount objects
        representing the members of the conversation.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_conversations_get_conversation_members_request(
            conversation_id=conversation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_conversation_member(
        self, conversation_id: str, member_id: str, **kwargs: Any
    ) -> JSON:
        """GetConversationMember.

        Get a single member of a conversation.

        This REST API takes a ConversationId and MemberId and returns a single ChannelAccount object,
        if that member is found in this conversation.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param member_id: Required.
        :type member_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aadObjectId": "str",
                    "id": "str",
                    "name": "str",
                    "role": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_conversations_get_conversation_member_request(
            conversation_id=conversation_id,
            member_id=member_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_conversation_member(
        self, conversation_id: str, member_id: str, **kwargs: Any
    ) -> None:
        """DeleteConversationMember.

        Deletes a member from a conversation.

        This REST API takes a ConversationId and a memberId (of type string) and removes that member
        from the conversation. If that member was the last member
        of the conversation, the conversation will also be deleted.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param member_id: ID of the member to delete from this conversation. Required.
        :type member_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_conversations_delete_conversation_member_request(
            conversation_id=conversation_id,
            member_id=member_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_conversation_paged_members(
        self,
        conversation_id: str,
        *,
        page_size: Optional[int] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """GetConversationPagedMembers.

        Enumerate the members of a conversation one page at a time.

        This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be
        provided. It returns a PagedMembersResult, which contains an array
        of ChannelAccounts representing the members of the conversation and a continuation token that
        can be used to get more values.

        One page of ChannelAccounts records are returned with each call. The number of records in a
        page may vary between channels and calls. The pageSize parameter can be used as
        a suggestion. If there are no additional results the response will not contain a continuation
        token. If there are no members in the conversation the Members will be empty or not present in
        the response.

        A response to a request that has a continuation token from a prior request may rarely return
        members from a previous request.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :keyword page_size: Suggested page size. Default value is None.
        :paramtype page_size: int
        :keyword continuation_token_parameter: Continuation Token. Default value is None.
        :paramtype continuation_token_parameter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuationToken": "str",
                    "members": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_conversations_get_conversation_paged_members_request(
            conversation_id=conversation_id,
            page_size=page_size,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_activity_members(
        self, conversation_id: str, activity_id: str, **kwargs: Any
    ) -> List[JSON]:
        """GetActivityMembers.

        Enumerate the members of an activity.

        This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount
        objects representing the members of the particular activity in the conversation.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param activity_id: Activity ID. Required.
        :type activity_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_conversations_get_activity_members_request(
            conversation_id=conversation_id,
            activity_id=activity_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    async def upload_attachment(
        self,
        conversation_id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """UploadAttachment.

        Upload an attachment directly into a channel's blob storage.

        This is useful because it allows you to store data in a compliant store when dealing with
        enterprises.

        The response is a ResourceResponse which contains an AttachmentId which is suitable for using
        with the attachments API.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Attachment data. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "originalBase64": bytes("bytes", encoding="utf-8"),
                    "thumbnailBase64": bytes("bytes", encoding="utf-8"),
                    "type": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @overload
    async def upload_attachment(
        self,
        conversation_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """UploadAttachment.

        Upload an attachment directly into a channel's blob storage.

        This is useful because it allows you to store data in a compliant store when dealing with
        enterprises.

        The response is a ResourceResponse which contains an AttachmentId which is suitable for using
        with the attachments API.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Attachment data. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """

    @distributed_trace_async
    async def upload_attachment(
        self,
        conversation_id: str,
        body: Optional[Union[JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        """UploadAttachment.

        Upload an attachment directly into a channel's blob storage.

        This is useful because it allows you to store data in a compliant store when dealing with
        enterprises.

        The response is a ResourceResponse which contains an AttachmentId which is suitable for using
        with the attachments API.

        :param conversation_id: Conversation ID. Required.
        :type conversation_id: str
        :param body: Attachment data. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "originalBase64": bytes("bytes", encoding="utf-8"),
                    "thumbnailBase64": bytes("bytes", encoding="utf-8"),
                    "type": "str"
                }

                # response body for status code(s): 200, 201, 202
                response == {
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_conversations_upload_attachment_request(
            conversation_id=conversation_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ConnectorInternalsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.agents.connector.Connector`'s
        :attr:`connector_internals` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    async def activity(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostActivity.

        PostActivity.

        :param body: Activity. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }
        """

    @overload
    async def activity(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostActivity.

        PostActivity.

        :param body: Activity. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def activity(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostActivity.

        PostActivity.

        :param body: Activity. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": "str",
                    "attachmentLayout": "str",
                    "attachments": [
                        {
                            "content": {},
                            "contentType": "str",
                            "contentUrl": "str",
                            "name": "str",
                            "thumbnailUrl": "str"
                        }
                    ],
                    "callerId": "str",
                    "channelData": {},
                    "channelId": "str",
                    "code": "str",
                    "conversation": {
                        "aadObjectId": "str",
                        "conversationType": "str",
                        "id": "str",
                        "isGroup": bool,
                        "name": "str",
                        "role": "str",
                        "tenantId": "str"
                    },
                    "deliveryMode": "str",
                    "entities": [
                        {
                            "type": "str"
                        }
                    ],
                    "expiration": "2020-02-20 00:00:00",
                    "from": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "historyDisclosed": bool,
                    "id": "str",
                    "importance": "str",
                    "inputHint": "str",
                    "label": "str",
                    "listenFor": [
                        "str"
                    ],
                    "localTimestamp": "2020-02-20 00:00:00",
                    "localTimezone": "str",
                    "locale": "str",
                    "membersAdded": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "membersRemoved": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ],
                    "name": "str",
                    "reactionsAdded": [
                        {
                            "type": "str"
                        }
                    ],
                    "reactionsRemoved": [
                        {
                            "type": "str"
                        }
                    ],
                    "recipient": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "replyToId": "str",
                    "semanticAction": {
                        "entities": {
                            "str": {
                                "type": "str"
                            }
                        },
                        "id": "str",
                        "state": "str"
                    },
                    "serviceUrl": "str",
                    "speak": "str",
                    "suggestedActions": {
                        "actions": [
                            {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            }
                        ],
                        "to": [
                            "str"
                        ]
                    },
                    "summary": "str",
                    "text": "str",
                    "textFormat": "str",
                    "textHighlights": [
                        {
                            "occurrence": 0,
                            "text": "str"
                        }
                    ],
                    "timestamp": "2020-02-20 00:00:00",
                    "topicName": "str",
                    "type": "str",
                    "value": {},
                    "valueType": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_activity_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def activity_event_names(
        self, body: Optional[str] = None, **kwargs: Any
    ) -> None:
        """PostActivityEventNames.

        PostActivityEventNames.

        :param body: ActivityEventNames. Known values are: "ContinueConversation" and
         "CreateConversation". Default value is None.
        :type body: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop(
            "content_type", _headers.pop("Content-Type", "application/json")
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is not None:
            _json = body
        else:
            _json = None

        _request = build_connector_internals_activity_event_names_request(
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def expected_replies(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostExpectedReplies.

        PostExpectedReplies.

        :param body: ExpectedReplies. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activities": [
                        {
                            "action": "str",
                            "attachmentLayout": "str",
                            "attachments": [
                                {
                                    "content": {},
                                    "contentType": "str",
                                    "contentUrl": "str",
                                    "name": "str",
                                    "thumbnailUrl": "str"
                                }
                            ],
                            "callerId": "str",
                            "channelData": {},
                            "channelId": "str",
                            "code": "str",
                            "conversation": {
                                "aadObjectId": "str",
                                "conversationType": "str",
                                "id": "str",
                                "isGroup": bool,
                                "name": "str",
                                "role": "str",
                                "tenantId": "str"
                            },
                            "deliveryMode": "str",
                            "entities": [
                                {
                                    "type": "str"
                                }
                            ],
                            "expiration": "2020-02-20 00:00:00",
                            "from": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "historyDisclosed": bool,
                            "id": "str",
                            "importance": "str",
                            "inputHint": "str",
                            "label": "str",
                            "listenFor": [
                                "str"
                            ],
                            "localTimestamp": "2020-02-20 00:00:00",
                            "localTimezone": "str",
                            "locale": "str",
                            "membersAdded": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "membersRemoved": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "name": "str",
                            "reactionsAdded": [
                                {
                                    "type": "str"
                                }
                            ],
                            "reactionsRemoved": [
                                {
                                    "type": "str"
                                }
                            ],
                            "recipient": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "relatesTo": {
                                "activityId": "str",
                                "bot": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                },
                                "channelId": "str",
                                "conversation": {
                                    "aadObjectId": "str",
                                    "conversationType": "str",
                                    "id": "str",
                                    "isGroup": bool,
                                    "name": "str",
                                    "role": "str",
                                    "tenantId": "str"
                                },
                                "locale": "str",
                                "serviceUrl": "str",
                                "user": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            },
                            "replyToId": "str",
                            "semanticAction": {
                                "entities": {
                                    "str": {
                                        "type": "str"
                                    }
                                },
                                "id": "str",
                                "state": "str"
                            },
                            "serviceUrl": "str",
                            "speak": "str",
                            "suggestedActions": {
                                "actions": [
                                    {
                                        "channelData": {},
                                        "displayText": "str",
                                        "image": "str",
                                        "imageAltText": "str",
                                        "text": "str",
                                        "title": "str",
                                        "type": "str",
                                        "value": {}
                                    }
                                ],
                                "to": [
                                    "str"
                                ]
                            },
                            "summary": "str",
                            "text": "str",
                            "textFormat": "str",
                            "textHighlights": [
                                {
                                    "occurrence": 0,
                                    "text": "str"
                                }
                            ],
                            "timestamp": "2020-02-20 00:00:00",
                            "topicName": "str",
                            "type": "str",
                            "value": {},
                            "valueType": "str"
                        }
                    ]
                }
        """

    @overload
    async def expected_replies(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostExpectedReplies.

        PostExpectedReplies.

        :param body: ExpectedReplies. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def expected_replies(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostExpectedReplies.

        PostExpectedReplies.

        :param body: ExpectedReplies. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activities": [
                        {
                            "action": "str",
                            "attachmentLayout": "str",
                            "attachments": [
                                {
                                    "content": {},
                                    "contentType": "str",
                                    "contentUrl": "str",
                                    "name": "str",
                                    "thumbnailUrl": "str"
                                }
                            ],
                            "callerId": "str",
                            "channelData": {},
                            "channelId": "str",
                            "code": "str",
                            "conversation": {
                                "aadObjectId": "str",
                                "conversationType": "str",
                                "id": "str",
                                "isGroup": bool,
                                "name": "str",
                                "role": "str",
                                "tenantId": "str"
                            },
                            "deliveryMode": "str",
                            "entities": [
                                {
                                    "type": "str"
                                }
                            ],
                            "expiration": "2020-02-20 00:00:00",
                            "from": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "historyDisclosed": bool,
                            "id": "str",
                            "importance": "str",
                            "inputHint": "str",
                            "label": "str",
                            "listenFor": [
                                "str"
                            ],
                            "localTimestamp": "2020-02-20 00:00:00",
                            "localTimezone": "str",
                            "locale": "str",
                            "membersAdded": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "membersRemoved": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ],
                            "name": "str",
                            "reactionsAdded": [
                                {
                                    "type": "str"
                                }
                            ],
                            "reactionsRemoved": [
                                {
                                    "type": "str"
                                }
                            ],
                            "recipient": {
                                "aadObjectId": "str",
                                "id": "str",
                                "name": "str",
                                "role": "str"
                            },
                            "relatesTo": {
                                "activityId": "str",
                                "bot": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                },
                                "channelId": "str",
                                "conversation": {
                                    "aadObjectId": "str",
                                    "conversationType": "str",
                                    "id": "str",
                                    "isGroup": bool,
                                    "name": "str",
                                    "role": "str",
                                    "tenantId": "str"
                                },
                                "locale": "str",
                                "serviceUrl": "str",
                                "user": {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            },
                            "replyToId": "str",
                            "semanticAction": {
                                "entities": {
                                    "str": {
                                        "type": "str"
                                    }
                                },
                                "id": "str",
                                "state": "str"
                            },
                            "serviceUrl": "str",
                            "speak": "str",
                            "suggestedActions": {
                                "actions": [
                                    {
                                        "channelData": {},
                                        "displayText": "str",
                                        "image": "str",
                                        "imageAltText": "str",
                                        "text": "str",
                                        "title": "str",
                                        "type": "str",
                                        "value": {}
                                    }
                                ],
                                "to": [
                                    "str"
                                ]
                            },
                            "summary": "str",
                            "text": "str",
                            "textFormat": "str",
                            "textHighlights": [
                                {
                                    "occurrence": 0,
                                    "text": "str"
                                }
                            ],
                            "timestamp": "2020-02-20 00:00:00",
                            "topicName": "str",
                            "type": "str",
                            "value": {},
                            "valueType": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_expected_replies_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def animation_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAnimationCard.

        PostAnimationCard.

        :param body: AnimationCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """

    @overload
    async def animation_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAnimationCard.

        PostAnimationCard.

        :param body: AnimationCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def animation_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostAnimationCard.

        PostAnimationCard.

        :param body: AnimationCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_animation_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def audio_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAudioCard.

        PostAudioCard.

        :param body: AudioCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """

    @overload
    async def audio_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAudioCard.

        PostAudioCard.

        :param body: AudioCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def audio_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostAudioCard.

        PostAudioCard.

        :param body: AudioCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_audio_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def basic_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostBasicCard.

        PostBasicCard.

        :param body: BasicCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "images": [
                        {
                            "alt": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "url": "str"
                        }
                    ],
                    "subtitle": "str",
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "text": "str",
                    "title": "str"
                }
        """

    @overload
    async def basic_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostBasicCard.

        PostBasicCard.

        :param body: BasicCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def basic_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostBasicCard.

        PostBasicCard.

        :param body: BasicCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "images": [
                        {
                            "alt": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "url": "str"
                        }
                    ],
                    "subtitle": "str",
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "text": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_basic_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def hero_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostHeroCard.

        PostHeroCard.

        :param body: HeroCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "images": [
                        {
                            "alt": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "url": "str"
                        }
                    ],
                    "subtitle": "str",
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "text": "str",
                    "title": "str"
                }
        """

    @overload
    async def hero_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostHeroCard.

        PostHeroCard.

        :param body: HeroCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def hero_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostHeroCard.

        PostHeroCard.

        :param body: HeroCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "images": [
                        {
                            "alt": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "url": "str"
                        }
                    ],
                    "subtitle": "str",
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "text": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_hero_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def media_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostMediaCard.

        PostMediaCard.

        :param body: MediaCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """

    @overload
    async def media_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostMediaCard.

        PostMediaCard.

        :param body: MediaCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def media_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostMediaCard.

        PostMediaCard.

        :param body: MediaCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_media_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def o_auth_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostOAuthCard.

        PostOAuthCard.

        :param body: OAuthCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "connectionName": "str",
                    "text": "str",
                    "tokenExchangeResource": {
                        "id": "str",
                        "providerId": "str",
                        "uri": "str"
                    }
                }
        """

    @overload
    async def o_auth_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostOAuthCard.

        PostOAuthCard.

        :param body: OAuthCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def o_auth_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostOAuthCard.

        PostOAuthCard.

        :param body: OAuthCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "connectionName": "str",
                    "text": "str",
                    "tokenExchangeResource": {
                        "id": "str",
                        "providerId": "str",
                        "uri": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_o_auth_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def receipt_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostReceiptCard.

        PostReceiptCard.

        :param body: ReceiptCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "facts": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "items": [
                        {
                            "image": {
                                "alt": "str",
                                "tap": {
                                    "channelData": {},
                                    "displayText": "str",
                                    "image": "str",
                                    "imageAltText": "str",
                                    "text": "str",
                                    "title": "str",
                                    "type": "str",
                                    "value": {}
                                },
                                "url": "str"
                            },
                            "price": "str",
                            "quantity": "str",
                            "subtitle": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "text": "str",
                            "title": "str"
                        }
                    ],
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "tax": "str",
                    "title": "str",
                    "total": "str",
                    "vat": "str"
                }
        """

    @overload
    async def receipt_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostReceiptCard.

        PostReceiptCard.

        :param body: ReceiptCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def receipt_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostReceiptCard.

        PostReceiptCard.

        :param body: ReceiptCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "facts": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "items": [
                        {
                            "image": {
                                "alt": "str",
                                "tap": {
                                    "channelData": {},
                                    "displayText": "str",
                                    "image": "str",
                                    "imageAltText": "str",
                                    "text": "str",
                                    "title": "str",
                                    "type": "str",
                                    "value": {}
                                },
                                "url": "str"
                            },
                            "price": "str",
                            "quantity": "str",
                            "subtitle": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "text": "str",
                            "title": "str"
                        }
                    ],
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "tax": "str",
                    "title": "str",
                    "total": "str",
                    "vat": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_receipt_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def signin_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostSigninCard.

        PostSigninCard.

        :param body: SigninCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "text": "str"
                }
        """

    @overload
    async def signin_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostSigninCard.

        PostSigninCard.

        :param body: SigninCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def signin_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostSigninCard.

        PostSigninCard.

        :param body: SigninCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "text": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_signin_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def thumbnail_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostThumbnailCard.

        PostThumbnailCard.

        :param body: ThumbnailCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "images": [
                        {
                            "alt": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "url": "str"
                        }
                    ],
                    "subtitle": "str",
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "text": "str",
                    "title": "str"
                }
        """

    @overload
    async def thumbnail_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostThumbnailCard.

        PostThumbnailCard.

        :param body: ThumbnailCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def thumbnail_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostThumbnailCard.

        PostThumbnailCard.

        :param body: ThumbnailCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "images": [
                        {
                            "alt": "str",
                            "tap": {
                                "channelData": {},
                                "displayText": "str",
                                "image": "str",
                                "imageAltText": "str",
                                "text": "str",
                                "title": "str",
                                "type": "str",
                                "value": {}
                            },
                            "url": "str"
                        }
                    ],
                    "subtitle": "str",
                    "tap": {
                        "channelData": {},
                        "displayText": "str",
                        "image": "str",
                        "imageAltText": "str",
                        "text": "str",
                        "title": "str",
                        "type": "str",
                        "value": {}
                    },
                    "text": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_thumbnail_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def video_card(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostVideoCard.

        PostVideoCard.

        :param body: VideoCard. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """

    @overload
    async def video_card(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostVideoCard.

        PostVideoCard.

        :param body: VideoCard. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def video_card(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostVideoCard.

        PostVideoCard.

        :param body: VideoCard. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "aspect": "str",
                    "autoloop": bool,
                    "autostart": bool,
                    "buttons": [
                        {
                            "channelData": {},
                            "displayText": "str",
                            "image": "str",
                            "imageAltText": "str",
                            "text": "str",
                            "title": "str",
                            "type": "str",
                            "value": {}
                        }
                    ],
                    "duration": "str",
                    "image": {
                        "alt": "str",
                        "url": "str"
                    },
                    "media": [
                        {
                            "profile": "str",
                            "url": "str"
                        }
                    ],
                    "shareable": bool,
                    "subtitle": "str",
                    "text": "str",
                    "title": "str",
                    "value": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_video_card_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def mention(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostMention.

        PostMention.

        :param body: Mention. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "mentioned": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "text": "str",
                    "type": "str"
                }
        """

    @overload
    async def mention(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostMention.

        PostMention.

        :param body: Mention. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def mention(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostMention.

        PostMention.

        :param body: Mention. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "mentioned": {
                        "aadObjectId": "str",
                        "id": "str",
                        "name": "str",
                        "role": "str"
                    },
                    "text": "str",
                    "type": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_mention_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def token_exchange_state(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeState.

        PostTokenExchangeState.

        :param body: TokenExchangeState. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "connectionName": "str",
                    "conversation": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "msAppId": "str",
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    }
                }
        """

    @overload
    async def token_exchange_state(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeState.

        PostTokenExchangeState.

        :param body: TokenExchangeState. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def token_exchange_state(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenExchangeState.

        PostTokenExchangeState.

        :param body: TokenExchangeState. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "connectionName": "str",
                    "conversation": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    },
                    "msAppId": "str",
                    "relatesTo": {
                        "activityId": "str",
                        "bot": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        },
                        "channelId": "str",
                        "conversation": {
                            "aadObjectId": "str",
                            "conversationType": "str",
                            "id": "str",
                            "isGroup": bool,
                            "name": "str",
                            "role": "str",
                            "tenantId": "str"
                        },
                        "locale": "str",
                        "serviceUrl": "str",
                        "user": {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_token_exchange_state_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def token_exchange_resource(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeResource.

        PostTokenExchangeResource.

        :param body: TokenExchangeResource. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "providerId": "str",
                    "uri": "str"
                }
        """

    @overload
    async def token_exchange_resource(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeResource.

        PostTokenExchangeResource.

        :param body: TokenExchangeResource. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def token_exchange_resource(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenExchangeResource.

        PostTokenExchangeResource.

        :param body: TokenExchangeResource. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",
                    "providerId": "str",
                    "uri": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_token_exchange_resource_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def token_exchange_invoke_request(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeInvokeRequest.

        PostTokenExchangeInvokeRequest.

        :param body: TokenExchangeInvokeRequest. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "connectionName": "str",
                    "token": "str"
                }
        """

    @overload
    async def token_exchange_invoke_request(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeInvokeRequest.

        PostTokenExchangeInvokeRequest.

        :param body: TokenExchangeInvokeRequest. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def token_exchange_invoke_request(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenExchangeInvokeRequest.

        PostTokenExchangeInvokeRequest.

        :param body: TokenExchangeInvokeRequest. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "connectionName": "str",
                    "token": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_token_exchange_invoke_request_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def token_exchange_invoke_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeInvokeResponse.

        PostTokenExchangeInvokeResponse.

        :param body: TokenExchangeInvokeResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "connectionName": "str",
                    "failureDetail": "str"
                }
        """

    @overload
    async def token_exchange_invoke_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenExchangeInvokeResponse.

        PostTokenExchangeInvokeResponse.

        :param body: TokenExchangeInvokeResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def token_exchange_invoke_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenExchangeInvokeResponse.

        PostTokenExchangeInvokeResponse.

        :param body: TokenExchangeInvokeResponse. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "connectionName": "str",
                    "failureDetail": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_token_exchange_invoke_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def invoke_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostInvokeResponse.

        PostInvokeResponse.

        :param body: InvokeResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "body": {},
                    "status": 0
                }
        """

    @overload
    async def invoke_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostInvokeResponse.

        PostInvokeResponse.

        :param body: InvokeResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def invoke_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostInvokeResponse.

        PostInvokeResponse.

        :param body: InvokeResponse. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "body": {},
                    "status": 0
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_invoke_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def token_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenResponse.

        PostTokenResponse.

        :param body: TokenResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """

    @overload
    async def token_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostTokenResponse.

        PostTokenResponse.

        :param body: TokenResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def token_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostTokenResponse.

        PostTokenResponse.

        :param body: TokenResponse. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "channelId": "str",
                    "connectionName": "str",
                    "expiration": "str",
                    "token": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_token_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def resource_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostResourceResponse.

        PostResourceResponse.

        :param body: ResourceResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str"
                }
        """

    @overload
    async def resource_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostResourceResponse.

        PostResourceResponse.

        :param body: ResourceResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def resource_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostResourceResponse.

        PostResourceResponse.

        :param body: ResourceResponse. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_resource_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def adaptive_card_invoke_action(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeAction.

        PostAdaptiveCardInvokeAction.

        :param body: AdaptiveCardInvokeAction. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": {},
                    "id": "str",
                    "type": "str",
                    "verb": "str"
                }
        """

    @overload
    async def adaptive_card_invoke_action(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeAction.

        PostAdaptiveCardInvokeAction.

        :param body: AdaptiveCardInvokeAction. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def adaptive_card_invoke_action(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeAction.

        PostAdaptiveCardInvokeAction.

        :param body: AdaptiveCardInvokeAction. Is either a JSON type or a IO[bytes] type. Default value
         is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "data": {},
                    "id": "str",
                    "type": "str",
                    "verb": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_adaptive_card_invoke_action_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def adaptive_card_invoke_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeResponse.

        PostAdaptiveCardInvokeResponse.

        :param body: AdaptiveCardInvokeResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "statusCode": 0,
                    "type": "str",
                    "value": {}
                }
        """

    @overload
    async def adaptive_card_invoke_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeResponse.

        PostAdaptiveCardInvokeResponse.

        :param body: AdaptiveCardInvokeResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def adaptive_card_invoke_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeResponse.

        PostAdaptiveCardInvokeResponse.

        :param body: AdaptiveCardInvokeResponse. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "statusCode": 0,
                    "type": "str",
                    "value": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_adaptive_card_invoke_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def adaptive_card_invoke_value(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeValue.

        PostAdaptiveCardInvokeValue.

        :param body: AdaptiveCardInvokeValue. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": {
                        "data": {},
                        "id": "str",
                        "type": "str",
                        "verb": "str"
                    },
                    "authentication": {
                        "connectionName": "str",
                        "token": "str"
                    },
                    "state": "str"
                }
        """

    @overload
    async def adaptive_card_invoke_value(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeValue.

        PostAdaptiveCardInvokeValue.

        :param body: AdaptiveCardInvokeValue. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def adaptive_card_invoke_value(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostAdaptiveCardInvokeValue.

        PostAdaptiveCardInvokeValue.

        :param body: AdaptiveCardInvokeValue. Is either a JSON type or a IO[bytes] type. Default value
         is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "action": {
                        "data": {},
                        "id": "str",
                        "type": "str",
                        "verb": "str"
                    },
                    "authentication": {
                        "connectionName": "str",
                        "token": "str"
                    },
                    "state": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_adaptive_card_invoke_value_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def search_invoke_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostSearchInvokeResponse.

        PostSearchInvokeResponse.

        :param body: SearchInvokeResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "statusCode": 0,
                    "type": "str",
                    "value": {}
                }
        """

    @overload
    async def search_invoke_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostSearchInvokeResponse.

        PostSearchInvokeResponse.

        :param body: SearchInvokeResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def search_invoke_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostSearchInvokeResponse.

        PostSearchInvokeResponse.

        :param body: SearchInvokeResponse. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "statusCode": 0,
                    "type": "str",
                    "value": {}
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_search_invoke_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def search_invoke_value(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostSearchInvokeValue.

        PostSearchInvokeValue.

        :param body: SearchInvokeValue. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "context": {},
                    "kind": "str",
                    "queryOptions": {},
                    "queryText": "str"
                }
        """

    @overload
    async def search_invoke_value(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostSearchInvokeValue.

        PostSearchInvokeValue.

        :param body: SearchInvokeValue. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def search_invoke_value(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostSearchInvokeValue.

        PostSearchInvokeValue.

        :param body: SearchInvokeValue. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "context": {},
                    "kind": "str",
                    "queryOptions": {},
                    "queryText": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_search_invoke_value_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def conversations_result(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostConversationsResult.

        PostConversationsResult.

        :param body: ConversationsResult. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "continuationToken": "str",
                    "conversations": [
                        {
                            "id": "str",
                            "members": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ]
                        }
                    ]
                }
        """

    @overload
    async def conversations_result(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostConversationsResult.

        PostConversationsResult.

        :param body: ConversationsResult. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def conversations_result(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostConversationsResult.

        PostConversationsResult.

        :param body: ConversationsResult. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "continuationToken": "str",
                    "conversations": [
                        {
                            "id": "str",
                            "members": [
                                {
                                    "aadObjectId": "str",
                                    "id": "str",
                                    "name": "str",
                                    "role": "str"
                                }
                            ]
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_conversations_result_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def paged_members_result(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostPagedMembersResult.

        PostPagedMembersResult.

        :param body: PagedMembersResult. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "continuationToken": "str",
                    "members": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ]
                }
        """

    @overload
    async def paged_members_result(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostPagedMembersResult.

        PostPagedMembersResult.

        :param body: PagedMembersResult. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def paged_members_result(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostPagedMembersResult.

        PostPagedMembersResult.

        :param body: PagedMembersResult. Is either a JSON type or a IO[bytes] type. Default value is
         None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "continuationToken": "str",
                    "members": [
                        {
                            "aadObjectId": "str",
                            "id": "str",
                            "name": "str",
                            "role": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_paged_members_result_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def attachment_info(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAttachmentInfo.

        PostAttachmentInfo.

        :param body: AttachmentInfo. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "type": "str",
                    "views": [
                        {
                            "size": 0,
                            "viewId": "str"
                        }
                    ]
                }
        """

    @overload
    async def attachment_info(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostAttachmentInfo.

        PostAttachmentInfo.

        :param body: AttachmentInfo. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def attachment_info(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostAttachmentInfo.

        PostAttachmentInfo.

        :param body: AttachmentInfo. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "type": "str",
                    "views": [
                        {
                            "size": 0,
                            "viewId": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_attachment_info_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def conversation_resource_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostConversationResourceResponse.

        PostConversationResourceResponse.

        :param body: ConversationResourceResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activityId": "str",
                    "id": "str",
                    "serviceUrl": "str"
                }
        """

    @overload
    async def conversation_resource_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostConversationResourceResponse.

        PostConversationResourceResponse.

        :param body: ConversationResourceResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def conversation_resource_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostConversationResourceResponse.

        PostConversationResourceResponse.

        :param body: ConversationResourceResponse. Is either a JSON type or a IO[bytes] type. Default
         value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "activityId": "str",
                    "id": "str",
                    "serviceUrl": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_conversation_resource_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def post_error_response(
        self,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostErrorResponse.

        PostErrorResponse.

        :param body: ErrorResponse. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "error": {
                        "code": "str",
                        "innerHttpError": {
                            "body": {},
                            "statusCode": 0
                        },
                        "message": "str"
                    }
                }
        """

    @overload
    async def post_error_response(
        self,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """PostErrorResponse.

        PostErrorResponse.

        :param body: ErrorResponse. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_error_response(
        self, body: Optional[Union[JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """PostErrorResponse.

        PostErrorResponse.

        :param body: ErrorResponse. Is either a JSON type or a IO[bytes] type. Default value is None.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "error": {
                        "code": "str",
                        "innerHttpError": {
                            "body": {},
                            "statusCode": 0
                        },
                        "message": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        _request = build_connector_internals_post_error_response_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in []:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
